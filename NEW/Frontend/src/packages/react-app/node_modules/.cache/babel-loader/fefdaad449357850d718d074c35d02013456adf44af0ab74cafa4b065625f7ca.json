{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig } from '../../..';\nimport { useConnector, useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nimport { useWindow } from '../../window/context';\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context';\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n}\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = _a => {\n  var {\n      isStatic,\n      lastUpdatedBlockNumber\n    } = _a,\n    strippedCall = __rest(_a, [\"isStatic\", \"lastUpdatedBlockNumber\"]);\n  return strippedCall;\n};\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({\n  children,\n  multicallAddresses\n}) {\n  const {\n    multicallVersion,\n    fastMulticallEncoding\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const dispatchNetworksState = useUpdateNetworksState();\n  const isActive = useWindow();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const {\n    reportError\n  } = useConnector();\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls]);\n  // used for deep equality in hook dependencies\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall));\n  const chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n  function multicallForChain(chainId, provider) {\n    if (!isActive) {\n      return;\n    }\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n    if (!provider || !blockNumber) {\n      return;\n    }\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n    const updatedCalls = getCallsForUpdate(debouncedCalls, {\n      chainId,\n      blockNumber\n    });\n    const callsOnThisChain = getUniqueActiveCalls(updatedCalls);\n    if (callsOnThisChain.length > 0 && !multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, error => {\n      dispatchNetworksState({\n        type: 'ADD_ERROR',\n        chainId,\n        error\n      });\n    });\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls,\n      updatedCalls,\n      blockNumber,\n      chainId\n    });\n  }\n  useEffect(() => {\n    var _a, _b;\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      const chainId = Number(_chainId);\n      // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n      if (chainId === ((_a = provider.network) === null || _a === void 0 ? void 0 : _a.chainId) || chainId === ((_b = provider._network) === null || _b === void 0 ? void 0 : _b.chainId)) {\n        multicallForChain(chainId, provider);\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"names":["useEffect","useMemo","useReducer","useDebouncePair","useBlockNumbers","MultiChainStatesContext","useConfig","useConnector","useReadonlyNetworks","fromEntries","performMulticall","callsReducer","chainStateReducer","multicall1Factory","multicall2Factory","getCallsForUpdate","getUniqueActiveCalls","useDevtoolsReporting","useChainId","useWindow","useUpdateNetworksState","composeChainState","networks","state","multicallAddresses","Object","keys","map","chainId","Number","value","multicallAddress","stripCall","_a","isStatic","lastUpdatedBlockNumber","strippedCall","__rest","MultiChainStateProvider","children","multicallVersion","fastMulticallEncoding","blockNumbers","dispatchNetworksState","isActive","calls","dispatchCalls","dispatchState","reportError","multicall","debouncedCalls","debouncedNetworks","uniqueCalls","uniqueCallsJSON","JSON","stringify","undefined","multicallForChain","provider","blockNumber","updatedCalls","callsOnThisChain","length","Error","error","type","_chainId","entries","network","_b","_network","chains","provided","_jsx","Provider"],"sources":["C:\\Users\\win\\Downloads\\clone res gi\\clone\\my-eth-app\\node_modules\\@usedapp\\core\\src\\providers\\chainState\\multiChainStates\\provider.tsx"],"sourcesContent":["import { ReactNode, useEffect, useMemo, useReducer } from 'react'\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks'\nimport { MultiChainStatesContext } from './context'\nimport { ChainId, State, useConfig } from '../../..'\nimport { useConnector, useReadonlyNetworks } from '../../network'\nimport { fromEntries } from '../../../helpers/fromEntries'\nimport { performMulticall } from '../common/performMulticall'\nimport { Providers } from '../../network/readonlyNetworks/model'\nimport { providers } from 'ethers'\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory, RawCall } from '../common'\nimport { getCallsForUpdate, getUniqueActiveCalls } from '../../../helpers'\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting'\nimport { useChainId } from '../../../hooks/useChainId'\nimport { useWindow } from '../../window/context'\nimport { useUpdateNetworksState } from '../../network/readonlyNetworks/context'\n\ninterface Props {\n  children: ReactNode\n  multicallAddresses: {\n    [chainId: number]: string\n  }\n}\n\nfunction composeChainState(networks: Providers, state: State, multicallAddresses: Props['multicallAddresses']) {\n  return fromEntries(\n    Object.keys(networks).map((chainId) => [\n      Number(chainId),\n      {\n        value: state[Number(chainId)],\n        multicallAddress: multicallAddresses[Number(chainId)],\n      },\n    ])\n  )\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst stripCall = ({ isStatic, lastUpdatedBlockNumber, ...strippedCall }: RawCall) => strippedCall\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({ children, multicallAddresses }: Props) {\n  const { multicallVersion, fastMulticallEncoding } = useConfig()\n  const networks = useReadonlyNetworks()\n  const blockNumbers = useBlockNumbers()\n  const dispatchNetworksState = useUpdateNetworksState()\n  const isActive = useWindow()\n\n  const [calls, dispatchCalls] = useReducer(callsReducer, [])\n  const [state, dispatchState] = useReducer(chainStateReducer, {})\n  const { reportError } = useConnector()\n\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding ?? false)\n\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50)\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls])\n\n  // used for deep equality in hook dependencies\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls.map(stripCall))\n\n  const chainId = useChainId()\n  useDevtoolsReporting(\n    uniqueCallsJSON,\n    uniqueCalls,\n    chainId !== undefined ? blockNumbers[chainId as ChainId] : undefined,\n    multicallAddresses\n  )\n\n  function multicallForChain(chainId: ChainId, provider: providers.BaseProvider) {\n    if (!isActive) {\n      return\n    }\n    const blockNumber = blockNumbers[chainId]\n    const multicallAddress = multicallAddresses[chainId]\n\n    if (!provider || !blockNumber) {\n      return\n    }\n\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return\n    }\n\n    const updatedCalls = getCallsForUpdate(debouncedCalls, { chainId, blockNumber })\n    const callsOnThisChain = getUniqueActiveCalls(updatedCalls)\n\n    if (callsOnThisChain.length > 0 && !multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`))\n      return\n    }\n\n    performMulticall(\n      provider,\n      multicall,\n      multicallAddress,\n      blockNumber,\n      callsOnThisChain,\n      dispatchState,\n      chainId,\n      (error) => {\n        dispatchNetworksState({\n          type: 'ADD_ERROR',\n          chainId,\n          error,\n        })\n      }\n    )\n    dispatchCalls({ type: 'UPDATE_CALLS', calls, updatedCalls, blockNumber, chainId })\n  }\n\n  useEffect(() => {\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      const chainId = Number(_chainId)\n      // chainId is in provider is not the same as the chainId in the state wait for chainId to catch up\n      if (chainId === provider.network?.chainId || chainId === provider._network?.chainId) {\n        multicallForChain(chainId, provider)\n      }\n    }\n  }, [networks, multicallAddresses, uniqueCallsJSON, blockNumbers])\n\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n    state,\n    multicallAddresses,\n    networks,\n  ])\n\n  const provided = { chains, dispatchCalls }\n\n  return <MultiChainStatesContext.Provider value={provided} children={children} />\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}